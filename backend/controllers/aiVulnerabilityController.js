import aiVulnerabilityScanner from '../utils/aiVulnerabilityScanner.js'
import { aggregateThreats } from '../utils/threatIntelService.js'

export const assessSingleVulnerability = async (req, res) => {
  try {
    const { vulnerability } = req.body

    if (!vulnerability) {
      return res.status(400).json({
        success: false,
        error: 'Vulnerability data is required'
      })
    }

    console.log('ðŸ§  Assessing single vulnerability:', vulnerability.cveId || vulnerability.id)

    const assessment = await aiVulnerabilityScanner.assessVulnerability(vulnerability)

    res.json({
      success: true,
      data: assessment,
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('Single vulnerability assessment error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to assess vulnerability',
      message: error.message
    })
  }
}

export const assessBatchVulnerabilities = async (req, res) => {
  try {
    const { vulnerabilities } = req.body

    if (!vulnerabilities || !Array.isArray(vulnerabilities)) {
      return res.status(400).json({
        success: false,
        error: 'Vulnerabilities array is required'
      })
    }

    console.log(`ðŸ§  Assessing ${vulnerabilities.length} vulnerabilities batch`)

    const result = await aiVulnerabilityScanner.assessVulnerabilities(vulnerabilities)

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('Batch vulnerability assessment error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to assess vulnerabilities batch',
      message: error.message
    })
  }
}

export const assessSystemVulnerabilities = async (req, res) => {
  try {
    const { systemId, scanType = 'comprehensive' } = req.params

    console.log(`ðŸ§  Assessing vulnerabilities for system: ${systemId}, type: ${scanType}`)

    // Get vulnerabilities from existing scan data
    let vulnerabilities = []

    if (scanType === 'recent') {
      // Get recent scans for this system
      vulnerabilities = await getRecentSystemVulnerabilities(systemId)
    } else {
      // Get comprehensive vulnerability data
      vulnerabilities = await getComprehensiveSystemVulnerabilities(systemId)
    }

    if (vulnerabilities.length === 0) {
      return res.json({
        success: true,
        data: {
          systemId,
          assessments: [],
          summary: {
            totalAssessed: 0,
            riskDistribution: { critical: 0, high: 0, medium: 0, low: 0 },
            averageRisk: 0,
            averageConfidence: 0,
            recommendations: []
          },
          timestamp: new Date().toISOString()
        },
        message: 'No vulnerabilities found for assessment'
      })
    }

    const result = await aiVulnerabilityScanner.assessVulnerabilities(vulnerabilities)

    // Add system-specific context
    result.systemId = systemId
    result.scanType = scanType

    res.json({
      success: true,
      data: result,
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('System vulnerability assessment error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to assess system vulnerabilities',
      message: error.message
    })
  }
}

export const getRiskPredictions = async (req, res) => {
  try {
    const { days = 30 } = req.query

    console.log(`ðŸ”® Generating risk predictions for ${days} days`)

    // Get current vulnerability data
    const vulnerabilities = await getAllCurrentVulnerabilities()

    if (vulnerabilities.length === 0) {
      return res.json({
        success: true,
        data: {
          predictions: [],
          summary: {
            totalVulnerabilities: 0,
            predictedRiskIncrease: 0,
            timeframes: ['24h', '7d', '30d'],
            recommendations: []
          }
        },
        timestamp: new Date().toISOString()
      })
    }

    // Assess all vulnerabilities
    const assessments = await aiVulnerabilityScanner.assessVulnerabilities(vulnerabilities)

    // Generate risk predictions based on timeline data
    const predictions = generateRiskPredictions(assessments.assessments, days)

    const summary = {
      totalVulnerabilities: assessments.assessments.length,
      predictedRiskIncrease: predictions.overallRiskIncrease,
      timeframes: predictions.timeframes,
      recommendations: generatePredictionRecommendations(predictions)
    }

    res.json({
      success: true,
      data: {
        predictions,
        summary,
        assessmentSummary: assessments.summary
      },
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('Risk prediction error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to generate risk predictions',
      message: error.message
    })
  }
}

export const getPatchRecommendations = async (req, res) => {
  try {
    const { priority = 'all' } = req.query

    console.log(`ðŸ’Š Generating patch recommendations, priority: ${priority}`)

    // Get vulnerabilities needing patches
    const vulnerabilities = await getVulnerabilitiesNeedingPatches(priority)

    if (vulnerabilities.length === 0) {
      return res.json({
        success: true,
        data: {
          recommendations: [],
          summary: {
            totalRecommendations: 0,
            criticalPatches: 0,
            highPriorityPatches: 0,
            estimatedEffort: '0 hours'
          }
        },
        message: 'No patches currently recommended'
      })
    }

    // Assess vulnerabilities for patch recommendations
    const assessments = await aiVulnerabilityScanner.assessVulnerabilities(vulnerabilities)

    // Generate intelligent patch recommendations
    const recommendations = generatePatchRecommendations(assessments.assessments)

    const summary = {
      totalRecommendations: recommendations.length,
      criticalPatches: recommendations.filter(r => r.priority === 'CRITICAL').length,
      highPriorityPatches: recommendations.filter(r => r.priority === 'HIGH').length,
      estimatedEffort: calculateEffortEstimate(recommendations)
    }

    res.json({
      success: true,
      data: {
        recommendations,
        summary,
        assessmentSummary: assessments.summary
      },
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('Patch recommendations error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to generate patch recommendations',
      message: error.message
    })
  }
}

export const getComplianceImpact = async (req, res) => {
  try {
    const { framework } = req.params

    console.log(`ðŸ“‹ Assessing compliance impact for framework: ${framework}`)

    // Get vulnerabilities affecting compliance
    const vulnerabilities = await getComplianceRelatedVulnerabilities(framework)

    if (vulnerabilities.length === 0) {
      return res.json({
        success: true,
        data: {
          framework,
          complianceScore: 100,
          impactedControls: [],
          remediationSteps: [],
          riskLevel: 'LOW'
        },
        message: 'No compliance-impacting vulnerabilities found'
      })
    }

    // Assess vulnerabilities for compliance impact
    const assessments = await aiVulnerabilityScanner.assessVulnerabilities(vulnerabilities)

    // Calculate compliance impact
    const complianceImpact = calculateComplianceImpact(assessments.assessments, framework)

    res.json({
      success: true,
      data: {
        framework,
        ...complianceImpact,
        assessmentSummary: assessments.summary
      },
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('Compliance impact assessment error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to assess compliance impact',
      message: error.message
    })
  }
}

export const getAIVulnerabilityInsights = async (req, res) => {
  try {
    console.log('ðŸ§  Generating AI vulnerability insights')

    // Get comprehensive vulnerability data
    const vulnerabilities = await getAllCurrentVulnerabilities()

    if (vulnerabilities.length === 0) {
      return res.json({
        success: true,
        data: {
          insights: [],
          trends: {},
          predictions: {},
          recommendations: []
        },
        message: 'No vulnerability data available for insights'
      })
    }

    // Assess all vulnerabilities
    const assessments = await aiVulnerabilityScanner.assessVulnerabilities(vulnerabilities)

    // Generate AI insights
    const insights = generateAIVulnerabilityInsights(assessments)

    res.json({
      success: true,
      data: insights,
      timestamp: new Date().toISOString()
    })

  } catch (error) {
    console.error('AI vulnerability insights error:', error)
    res.status(500).json({
      success: false,
      error: 'Failed to generate AI insights',
      message: error.message
    })
  }
}

// Helper functions for data retrieval
async function getRecentSystemVulnerabilities(systemId) {
  // Mock implementation - in production, query database
  return [
    {
      id: 'CVE-2023-12345',
      cveId: 'CVE-2023-12345',
      cvssScore: 8.5,
      severity: 'HIGH',
      affectedSystems: [{ id: systemId, criticality: 'HIGH' }],
      disclosedDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
      exploitCode: true,
      internetExposed: true
    }
  ]
}

async function getComprehensiveSystemVulnerabilities(systemId) {
  // Mock implementation - in production, query database
  return [
    {
      id: 'CVE-2023-12345',
      cveId: 'CVE-2023-12345',
      cvssScore: 8.5,
      severity: 'HIGH',
      affectedSystems: [{ id: systemId, criticality: 'HIGH' }],
      disclosedDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
      exploitCode: true,
      internetExposed: true
    },
    {
      id: 'CVE-2023-23456',
      cveId: 'CVE-2023-23456',
      cvssScore: 6.2,
      severity: 'MEDIUM',
      affectedSystems: [{ id: systemId, criticality: 'MEDIUM' }],
      disclosedDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
      metasploitModule: true
    }
  ]
}

async function getAllCurrentVulnerabilities() {
  // Mock implementation - in production, query database
  return [
    {
      id: 'CVE-2023-12345',
      cveId: 'CVE-2023-12345',
      cvssScore: 8.5,
      severity: 'HIGH',
      disclosedDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
      exploitCode: true,
      internetExposed: true
    },
    {
      id: 'CVE-2023-23456',
      cveId: 'CVE-2023-23456',
      cvssScore: 6.2,
      severity: 'MEDIUM',
      disclosedDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
      metasploitModule: true
    },
    {
      id: 'CVE-2023-34567',
      cveId: 'CVE-2023-34567',
      cvssScore: 9.1,
      severity: 'CRITICAL',
      disclosedDate: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000).toISOString(),
      weaponized: true,
      remoteExploit: true
    }
  ]
}

async function getVulnerabilitiesNeedingPatches(priority) {
  const allVulns = await getAllCurrentVulnerabilities()

  if (priority === 'critical') {
    return allVulns.filter(v => v.severity === 'CRITICAL' || v.cvssScore >= 9.0)
  } else if (priority === 'high') {
    return allVulns.filter(v => v.severity === 'HIGH' || v.cvssScore >= 7.0)
  }

  return allVulns
}

async function getComplianceRelatedVulnerabilities(framework) {
  const allVulns = await getAllCurrentVulnerabilities()

  // Filter based on compliance framework
  return allVulns.filter(vuln => {
    switch (framework.toUpperCase()) {
      case 'PCI-DSS':
        return vuln.affectsCardholderData || vuln.cvssScore >= 4.0
      case 'HIPAA':
        return vuln.affectsHealthData || vuln.cvssScore >= 4.0
      case 'NIST':
        return vuln.severity === 'HIGH' || vuln.severity === 'CRITICAL'
      case 'ISO27001':
        return vuln.cvssScore >= 5.0
      default:
        return vuln.cvssScore >= 6.0
    }
  })
}

// Helper functions for analysis
function generateRiskPredictions(assessments, days) {
  const timeframes = ['24h', '7d', '30d']
  const predictions = {}

  timeframes.forEach(timeframe => {
    const riskIncrease = assessments.reduce((sum, assessment) => {
      const timelineEntry = assessment.riskTimeline.find(t => t.timeframe === timeframe)
      return sum + (timelineEntry ? timelineEntry.riskIncrease : 0)
    }, 0) / assessments.length

    const avgPredictedRisk = assessments.reduce((sum, assessment) => {
      const timelineEntry = assessment.riskTimeline.find(t => t.timeframe === timeframe)
      return sum + (timelineEntry ? timelineEntry.predictedRisk : assessment.aiRiskScore)
    }, 0) / assessments.length

    predictions[timeframe] = {
      riskIncrease: Math.round(riskIncrease * 100) / 100,
      predictedAverageRisk: Math.round(avgPredictedRisk * 100) / 100,
      criticalVulnerabilities: assessments.filter(a => {
        const timelineEntry = a.riskTimeline.find(t => t.timeframe === timeframe)
        return timelineEntry && timelineEntry.predictedRisk > 0.8
      }).length
    }
  })

  const overallRiskIncrease = Object.values(predictions).reduce((sum, pred) =>
    sum + pred.riskIncrease, 0) / timeframes.length

  return {
    timeframes,
    predictions,
    overallRiskIncrease: Math.round(overallRiskIncrease * 100) / 100
  }
}

function generatePredictionRecommendations(predictions) {
  const recommendations = []

  if (predictions.overallRiskIncrease > 0.3) {
    recommendations.push({
      priority: 'CRITICAL',
      action: 'Immediate risk mitigation required',
      reasoning: `Risk predicted to increase by ${predictions.overallRiskIncrease * 100}% in next 30 days`
    })
  }

  const criticalCount = Object.values(predictions.predictions).reduce((sum, pred) =>
    sum + pred.criticalVulnerabilities, 0)

  if (criticalCount > 0) {
    recommendations.push({
      priority: 'HIGH',
      action: `Address ${criticalCount} vulnerabilities predicted to become critical`,
      reasoning: 'Proactive risk management'
    })
  }

  return recommendations
}

function generatePatchRecommendations(assessments) {
  return assessments.map(assessment => ({
    vulnerabilityId: assessment.vulnerabilityId,
    priority: assessment.recommendations[0]?.priority || 'MEDIUM',
    patchAction: assessment.recommendations[0]?.action || 'Review and patch',
    businessImpact: assessment.businessImpact > 0.7 ? 'HIGH' : assessment.businessImpact > 0.4 ? 'MEDIUM' : 'LOW',
    estimatedEffort: calculatePatchEffort(assessment),
    dependencies: assessment.context.factors.filter(f => f.type === 'cwe').length,
    complianceImpact: assessment.context.businessContext.complianceImpact.severity
  }))
}

function calculatePatchEffort(assessment) {
  let effort = 2 // Base 2 hours

  if (assessment.aiRiskScore > 0.8) effort += 4
  else if (assessment.aiRiskScore > 0.6) effort += 2

  if (assessment.context.factors.length > 3) effort += 1
  if (assessment.businessImpact > 0.7) effort += 2

  return `${effort} hours`
}

function calculateEffortEstimate(recommendations) {
  const totalHours = recommendations.reduce((sum, rec) => {
    const hours = parseInt(rec.estimatedEffort.split(' ')[0])
    return sum + hours
  }, 0)

  return `${totalHours} hours`
}

function calculateComplianceImpact(assessments, framework) {
  const complianceScore = 100 - (assessments.reduce((sum, a) => sum + a.aiRiskScore, 0) / assessments.length * 20)

  const impactedControls = assessments.map(a => ({
    vulnerabilityId: a.vulnerabilityId,
    impactLevel: a.aiRiskScore > 0.7 ? 'HIGH' : a.aiRiskScore > 0.5 ? 'MEDIUM' : 'LOW',
    affectedControls: getFrameworkControls(framework, a)
  }))

  return {
    complianceScore: Math.max(0, Math.round(complianceScore)),
    impactedControls,
    remediationSteps: generateRemediationSteps(assessments, framework),
    riskLevel: complianceScore < 70 ? 'HIGH' : complianceScore < 85 ? 'MEDIUM' : 'LOW'
  }
}

function getFrameworkControls(framework, assessment) {
  // Mock framework controls - in production, use actual framework mappings
  const controls = {
    'PCI-DSS': ['Requirement 6.2', 'Requirement 6.3'],
    'HIPAA': ['Technical Safeguards', 'Security Management'],
    'NIST': ['AC-2', 'AC-3', 'SI-2'],
    'ISO27001': ['A.12.6', 'A.12.7']
  }

  return controls[framework.toUpperCase()] || ['General Controls']
}

function generateRemediationSteps(assessments, framework) {
  return assessments
    .filter(a => a.aiRiskScore > 0.5)
    .map(a => ({
      vulnerabilityId: a.vulnerabilityId,
      steps: [
        'Conduct impact assessment',
        'Develop remediation plan',
        'Implement compensating controls',
        'Schedule and apply patches',
        'Validate remediation effectiveness'
      ],
      priority: a.recommendations[0]?.priority || 'MEDIUM'
    }))
}

function generateAIVulnerabilityInsights(assessments) {
  const insights = []

  // Risk distribution insight
  const riskDistribution = {
    critical: assessments.assessments.filter(a => a.aiRiskScore > 0.8).length,
    high: assessments.assessments.filter(a => a.aiRiskScore > 0.6 && a.aiRiskScore <= 0.8).length,
    medium: assessments.assessments.filter(a => a.aiRiskScore > 0.4 && a.aiRiskScore <= 0.6).length,
    low: assessments.assessments.filter(a => a.aiRiskScore <= 0.4).length
  }

  insights.push({
    type: 'risk_distribution',
    title: 'Risk Distribution Analysis',
    description: `AI analysis shows ${riskDistribution.critical} critical, ${riskDistribution.high} high, ${riskDistribution.medium} medium, and ${riskDistribution.low} low-risk vulnerabilities`,
    data: riskDistribution,
    confidence: assessments.summary.averageConfidence
  })

  // Exploitability trends
  const highExploitability = assessments.assessments.filter(a => a.exploitabilityScore > 0.7).length
  if (highExploitability > 0) {
    insights.push({
      type: 'exploitability_trend',
      title: 'High Exploitability Alert',
      description: `${highExploitability} vulnerabilities have high exploitability scores, indicating imminent threat`,
      recommendation: 'Prioritize patching of these vulnerabilities',
      severity: 'HIGH'
    })
  }

  // Business impact insights
  const highBusinessImpact = assessments.assessments.filter(a => a.businessImpact > 0.7).length
  if (highBusinessImpact > 0) {
    insights.push({
      type: 'business_impact',
      title: 'Business Impact Assessment',
      description: `${highBusinessImpact} vulnerabilities could significantly impact business operations`,
      recommendation: 'Conduct business impact analysis for critical systems',
      severity: 'HIGH'
    })
  }

  return {
    insights,
    trends: {
      riskIncrease: assessments.summary.averageRisk > 0.6 ? 'increasing' : 'stable',
      confidence: assessments.summary.averageConfidence,
      totalAssessed: assessments.assessments.length
    },
    predictions: {
      nextWeekRisk: assessments.summary.averageRisk + 0.1,
      nextMonthRisk: assessments.summary.averageRisk + 0.2
    },
    recommendations: assessments.summary.recommendations
  }
}
