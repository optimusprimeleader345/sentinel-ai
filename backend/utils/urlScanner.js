import { google } from 'googleapis'

const safeBrowsing = google.safebrowsing('v4')

// Suspicious TLDs to flag
const SUSPICIOUS_TLDS = ['.ru', '.cn', '.tk', '.ga', '.ml', '.cf', '.gq', '.top', '.xyz', '.tk', '.ga', '.ml', '.cf', '.gq', '.vn']

// Phishing keywords commonly found in malicious URLs
const SUSPICIOUS_KEYWORDS = [
  'login', 'account', 'verify', 'secure', 'update', 'confirm', 'auth', 'signin',
  'password', 'bank', 'paypal', 'amazon', 'apple', 'microsoft', 'google', 'facebook',
  'instagram', 'twitter', 'bitcoin', 'crypto', 'virus', 'malware', 'hack', 'exploit'
]

/**
 * Validate URL format
 */
function isValidUrl(urlString) {
  try {
    const url = new URL(urlString)
    return url.protocol === 'http:' || url.protocol === 'https:'
  } catch (err) {
    return false
  }
}

/**
 * Extract domain from URL
 */
function extractDomain(urlString) {
  try {
    const url = new URL(urlString)
    return url.hostname.toLowerCase()
  } catch (err) {
    return null
  }
}

/**
 * Check URL against Google SafeBrowsing API
 */
async function checkSafeBrowsing(url) {
  const apiKey = process.env.SAFEBROWSING_KEY
  if (!apiKey) {
    console.warn('Google SafeBrowsing API key not configured')
    return { hits: [], checked: false }
  }

  try {
    const response = await safeBrowsing.threatMatches.find({
      auth: apiKey,
      requestBody: {
        client: {
          clientId: "sentinel-ai",
          clientVersion: "1.0.0"
        },
        threatInfo: {
          threatTypes: ["MALWARE", "SOCIAL_ENGINEERING", "UNWANTED_SOFTWARE", "POTENTIALLY_HARMFUL_APPLICATION"],
          platformTypes: ["ANY_PLATFORM"],
          threatEntryTypes: ["URL"],
          threatEntries: [{ url }]
        }
      }
    })

    return {
      hits: response.data.matches || [],
      checked: true,
      hitCount: response.data.matches?.length || 0
    }
  } catch (error) {
    console.error('SafeBrowsing API error:', error.message)
    return { hits: [], checked: false, error: error.message }
  }
}

/**
 * Analyze domain patterns for suspicious characteristics
 */
function analyzeDomainPatterns(domain) {
  const patterns = []

  // Check for suspicious TLDs
  const tld = domain.substring(domain.lastIndexOf('.'))
  if (SUSPICIOUS_TLDS.includes(tld)) {
    patterns.push({
      type: 'suspicious_tld',
      severity: 'MEDIUM',
      description: `Suspicious top-level domain: ${tld}`,
      score: 20
    })
  }

  // Check for IP-based hosts (numbers in domain name suggest potential scam)
  if (/^\d+\.\d+\.\d+\.\d+$/.test(domain)) {
    patterns.push({
      type: 'ip_based',
      severity: 'HIGH',
      description: 'IP address used directly as hostname',
      score: 40
    })
  }

  // Check for extremely short domains (often scam/malware sites)
  const mainDomain = domain.replace(/^www\./, '').split('.')[0]
  if (mainDomain.length < 4 && mainDomain !== 'ai' && mainDomain !== 'io' && mainDomain !== 'co') {
    patterns.push({
      type: 'short_domain',
      severity: 'MEDIUM',
      description: 'Extremely short domain name',
      score: 15
    })
  }

  // Check for random character patterns (often autogenerated scam domains)
  if (/[a-zA-Z]{15,}/.test(mainDomain)) {
    patterns.push({
      type: 'random_chars',
      severity: 'HIGH',
      description: 'Random character pattern suggests autogenerated scam domain',
      score: 35
    })
  }

  // Check for numeric domains (services abusing numbers in names)
  if (/^\d+[a-zA-Z]+\d*$/.test(mainDomain) || /^\d+$/.test(mainDomain)) {
    patterns.push({
      type: 'numeric_domain',
      severity: 'MEDIUM',
      description: 'Domain contains suspicious number patterns',
      score: 20
    })
  }

  return patterns
}

/**
 * Analyze URL path and query parameters for suspicious content
 */
function analyzeUrlContent(urlString) {
  const patterns = []

  try {
    const url = new URL(urlString)
    const pathAndQuery = url.pathname + url.search + url.hash

    // Check for suspicious keywords in URL path
    const lowerPath = pathAndQuery.toLowerCase()
    const foundKeywords = SUSPICIOUS_KEYWORDS.filter(keyword =>
      lowerPath.includes(keyword.toLowerCase())
    )

    if (foundKeywords.length > 0) {
      patterns.push({
        type: 'suspicious_keywords',
        severity: 'MEDIUM',
        description: `Found suspicious keywords: ${foundKeywords.join(', ')}`,
        score: Math.min(foundKeywords.length * 5, 25),
        keywords: foundKeywords
      })
    }

    // Check for excessive query parameters (often used in phishing)
    const queryParams = new URLSearchParams(url.search)
    if (queryParams.toString().length > 200) {
      patterns.push({
        type: 'excessive_params',
        severity: 'LOW',
        description: 'Unusually long query parameters',
        score: 10
      })
    }

    // Check for URL shorteners (common in phishing)
    const shorteners = ['bit.ly', 'tinyurl.com', 'goo.gl', 't.co', 'ow.ly', 'fb.me', 'is.gd']
    if (shorteners.includes(url.hostname)) {
      patterns.push({
        type: 'url_shortener',
        severity: 'HIGH',
        description: 'URL uses link shortener service',
        score: 45
      })
    }

    // Check if protocol is not HTTPS (modern sites should use HTTPS)
    if (url.protocol !== 'https:') {
      patterns.push({
        type: 'non_ssl',
        severity: 'LOW',
        description: 'URL does not use HTTPS encryption',
        score: 10
      })
    }

  } catch (err) {
    patterns.push({
      type: 'url_parse_error',
      severity: 'MEDIUM',
      description: 'Failed to parse URL structure',
      score: 15
    })
  }

  return patterns
}

/**
 * Check VirusTotal API if configured
 */
async function checkVirusTotal(url) {
  const apiKey = process.env.VIRUSTOTAL_KEY

  if (!apiKey) {
    return { checked: false, unavailable: true }
  }

  try {
    // VirusTotal API requires submitting URL first to get analysis
    // This is a simplified implementation - real implementation would handle rate limits
    const vtResponse = {
      checked: true,
      malicious: 0,
      suspicious: 0,
      harmless: 0,
      totalScans: 0,
      scanDate: new Date().toISOString()
    }

    // Mock data for demonstration - replace with real API call
    return vtResponse

  } catch (error) {
    console.error('VirusTotal API error:', error.message)
    return { checked: false, error: error.message }
  }
}

/**
 * Calculate overall risk score
 */
function calculateRiskScore(safeBrowsing, domainPatterns, urlPatterns, virusTotal) {
  let score = 0
  const reasons = []

  // SafeBrowsing hits (50 points each)
  if (safeBrowsing.hits?.length > 0) {
    score += safeBrowsing.hits.length * 50
    reasons.push(`${safeBrowsing.hits.length} SafeBrowsing threat(s) detected`)
  }

  // Domain patterns
  domainPatterns.forEach(pattern => {
    score += pattern.score
    reasons.push(pattern.description)
  })

  // URL content patterns
  urlPatterns.forEach(pattern => {
    score += pattern.score
    reasons.push(pattern.description)
  })

  // VirusTotal (if available)
  if (virusTotal.checked && virusTotal.malicious > 0) {
    score += Math.min(virusTotal.malicious * 20, 100)
    reasons.push(`${virusTotal.malicious} antivirus engines flagged as malicious`)
  }

  return { score: Math.min(score, 100), reasons }
}

/**
 * Determine risk level based on score
 */
function getRiskLevel(score) {
  if (score > 90) return 'HIGH'
  if (score > 50) return 'MEDIUM'
  return 'LOW'
}

/**
 * Generate security suggestions based on analysis
 */
function generateSuggestions(score, riskLevel, findings) {
  const suggestions = []

  if (riskLevel === 'HIGH') {
    suggestions.push('Do NOT visit this website - it poses severe security risks')
    suggestions.push('Report this URL to your security team immediately')
    if (findings.safeBrowsingHits?.length > 0) {
      suggestions.push('This URL is actively flagged by Google SafeBrowsing as dangerous')
    }
  } else if (riskLevel === 'MEDIUM') {
    suggestions.push('Exercise extreme caution before visiting this site')
    suggestions.push('Consider alternative websites for this service')
    suggestions.push('Use additional verification methods before entering any information')
  } else {
    suggestions.push('Website appears safe based on current analysis')
    suggestions.push('Continue practicing safe browsing habits')
  }

  // Specific suggestions based on findings
  if (findings.domainPatterns.some(p => p.type === 'ip_based')) {
    suggestions.push('Direct IP addresses instead of domain names are suspicious')
  }

  if (findings.urlPatterns.some(p => p.type === 'non_ssl')) {
    suggestions.push('Ensure websites use HTTPS encryption for secure communication')
  }

  if (findings.urlPatterns.some(p => p.type === 'url_shortener')) {
    suggestions.push('Expand shortened URLs before clicking to reveal their true destination')
  }

  return suggestions
}

/**
 * Main URL scanning function
 */
export async function scanURL(urlString) {
  try {
    // Basic validation
    if (!isValidUrl(urlString)) {
      throw new Error('Invalid URL format')
    }

    const domain = extractDomain(urlString)

    if (!domain) {
      throw new Error('Could not extract domain from URL')
    }

    // Perform all checks in parallel when possible
    const [safeBrowsingResult, virusTotalResult] = await Promise.all([
      checkSafeBrowsing(urlString),
      checkVirusTotal(urlString)
    ])

    // Analyze patterns
    const domainPatterns = analyzeDomainPatterns(domain)
    const urlPatterns = analyzeUrlContent(urlString)

    // Calculate risk score and level
    const { score, reasons } = calculateRiskScore(
      safeBrowsingResult,
      domainPatterns,
      urlPatterns,
      virusTotalResult
    )
    const riskLevel = getRiskLevel(score)
    const isSafe = riskLevel === 'LOW'

    // Generate suggestions
    const suggestions = generateSuggestions(score, riskLevel, {
      safeBrowsingHits: safeBrowsingResult.hits,
      domainPatterns,
      urlPatterns
    })

    return {
      url: urlString,
      isSafe,
      safeBrowsingResults: safeBrowsingResult.hits?.map(hit => ({
        threatType: hit.threatType,
        platformType: hit.platformType,
        cacheDuration: hit.cacheDuration
      })) || [],
      virusTotal: virusTotalResult.checked ? [{
        malicious: virusTotalResult.malicious || 0,
        suspicious: virusTotalResult.suspicious || 0,
        harmless: virusTotalResult.harmless || 0,
        totalScans: virusTotalResult.totalScans || 0,
        scanDate: virusTotalResult.scanDate
      }] : [],
      suspiciousPatterns: [...domainPatterns, ...urlPatterns].map(p => ({
        type: p.type,
        severity: p.severity,
        description: p.description,
        ...(p.keywords && { keywords: p.keywords })
      })),
      riskLevel,
      score,
      reason: reasons,
      suggestions,
      analysis: {
        domain,
        tld: domain.substring(domain.lastIndexOf('.')),
        protocol: urlString.startsWith('https://') ? 'https' : 'http',
        safeBrowsingChecked: safeBrowsingResult.checked,
        virusTotalChecked: virusTotalResult.checked,
        totalIndicators: domainPatterns.length + urlPatterns.length
      }
    }

  } catch (error) {
    console.error('URL scanning error:', error)
    return {
      url: urlString,
      isSafe: false,
      safeBrowsingResults: [],
      virusTotal: [],
      suspiciousPatterns: [{
        type: 'scan_error',
        severity: 'HIGH',
        description: `Scan failed: ${error.message}`
      }],
      riskLevel: 'ERROR',
      score: 0,
      reason: [error.message],
      suggestions: ['Unable to scan URL due to processing error'],
      analysis: { error: error.message }
    }
  }
}

export default { scanURL }
