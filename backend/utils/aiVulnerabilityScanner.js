/**
 * AI-Powered Vulnerability Assessment Engine
 * Uses machine learning to score vulnerabilities and predict risks
 */

class AIVulnerabilityScanner {
  constructor() {
    this.mlModel = this.initializeMLModel();
    this.riskWeights = {
      exploitability: 0.3,
      impact: 0.25,
      exposure: 0.2,
      businessImpact: 0.15,
      temporalFactors: 0.1
    };
  }

  /**
   * Initialize ML model for vulnerability scoring
   */
  initializeMLModel() {
    // Mock ML model - in production, this would load a trained model
    return {
      predictRisk: (vulnerability) => this.calculateMLRiskScore(vulnerability),
      predictExploitability: (vulnerability) => this.calculateExploitabilityScore(vulnerability),
      predictBusinessImpact: (vulnerability) => this.calculateBusinessImpact(vulnerability)
    };
  }

  /**
   * Comprehensive vulnerability assessment with AI scoring
   */
  async assessVulnerability(vulnerability) {
    try {
      const startTime = Date.now();

      // Gather vulnerability context
      const context = await this.gatherVulnerabilityContext(vulnerability);

      // Calculate AI-powered scores
      const aiScores = await this.calculateAIScores(vulnerability, context);

      // Generate recommendations
      const recommendations = await this.generateRecommendations(vulnerability, aiScores, context);

      // Calculate risk timeline
      const riskTimeline = this.calculateRiskTimeline(vulnerability, aiScores);

      const assessmentTime = Date.now() - startTime;

      return {
        vulnerabilityId: vulnerability.id || vulnerability.cveId,
        aiRiskScore: aiScores.overallRisk,
        confidence: aiScores.confidence,
        exploitabilityScore: aiScores.exploitability,
        businessImpact: aiScores.businessImpact,
        recommendations: recommendations,
        riskTimeline: riskTimeline,
        assessmentMetadata: {
          assessedAt: new Date().toISOString(),
          assessmentTime: `${assessmentTime}ms`,
          modelVersion: '1.0.0',
          factors: context.factors.length
        },
        context: context
      };
    } catch (error) {
      console.error('AI Vulnerability Assessment Error:', error);
      return this.generateFallbackAssessment(vulnerability);
    }
  }

  /**
   * Gather comprehensive vulnerability context
   */
  async gatherVulnerabilityContext(vuln) {
    const context = {
      factors: [],
      relatedVulnerabilities: [],
      affectedSystems: [],
      exploitabilityIndicators: [],
      businessContext: {}
    };

    // CVSS Analysis
    if (vuln.cvssScore) {
      context.factors.push({
        type: 'cvss',
        score: vuln.cvssScore,
        vector: vuln.cvssVector,
        weight: 0.3
      });
    }

    // CWE Analysis
    if (vuln.cwe) {
      context.factors.push({
        type: 'cwe',
        id: vuln.cwe,
        description: this.getCWEDescription(vuln.cwe),
        weight: 0.2
      });
    }

    // Exploitability Indicators
    if (vuln.exploitCode) context.exploitabilityIndicators.push('public_exploit');
    if (vuln.metasploitModule) context.exploitabilityIndicators.push('metasploit_module');
    if (vuln.weaponized) context.exploitabilityIndicators.push('weaponized');

    // Temporal Factors
    const daysSinceDisclosure = vuln.disclosedDate ?
      Math.floor((Date.now() - new Date(vuln.disclosedDate)) / (1000 * 60 * 60 * 24)) : 0;

    context.factors.push({
      type: 'temporal',
      daysSinceDisclosure,
      weight: 0.1
    });

    // Asset Value Assessment
    context.businessContext = {
      assetValue: this.assessAssetValue(vuln.affectedSystems || []),
      exposureLevel: this.calculateExposureLevel(vuln),
      complianceImpact: this.assessComplianceImpact(vuln)
    };

    return context;
  }

  /**
   * Calculate AI-powered risk scores using ML model
   */
  async calculateAIScores(vulnerability, context) {
    const mlModel = this.mlModel;

    // ML-based risk prediction
    const mlRisk = mlModel.predictRisk(vulnerability);
    const exploitability = mlModel.predictExploitability(vulnerability);
    const businessImpact = mlModel.predictBusinessImpact(vulnerability);

    // Combine ML predictions with rule-based scoring
    const ruleBasedRisk = this.calculateRuleBasedRisk(vulnerability, context);

    // Ensemble scoring (weighted average of ML and rule-based)
    const overallRisk = (mlRisk.score * 0.7) + (ruleBasedRisk * 0.3);

    // Calculate confidence based on data quality and consistency
    const confidence = this.calculateConfidence(mlRisk, ruleBasedRisk, context);

    return {
      overallRisk: Math.round(overallRisk * 100) / 100,
      exploitability: Math.round(exploitability * 100) / 100,
      businessImpact: Math.round(businessImpact * 100) / 100,
      mlConfidence: mlRisk.confidence,
      ruleConfidence: 0.9, // Rule-based is generally reliable
      confidence: Math.round(confidence * 100) / 100
    };
  }

  /**
   * ML-based risk score calculation
   */
  calculateMLRiskScore(vuln) {
    let score = 0.5; // Base score
    let confidence = 0.7;

    // CVSS-based scoring
    if (vuln.cvssScore) {
      score = vuln.cvssScore / 10; // Normalize to 0-1
      confidence += 0.1;
    }

    // Exploitability factors
    if (vuln.exploitCode) score += 0.2;
    if (vuln.metasploitModule) score += 0.3;
    if (vuln.weaponized) score += 0.4;

    // Temporal decay (newer vulnerabilities are riskier)
    const daysOld = vuln.disclosedDate ?
      Math.floor((Date.now() - new Date(vuln.disclosedDate)) / (1000 * 60 * 60 * 24)) : 0;

    if (daysOld < 30) score += 0.1;
    else if (daysOld > 365) score -= 0.1;

    // Clamp score
    score = Math.max(0, Math.min(1, score));

    return { score, confidence };
  }

  /**
   * Calculate exploitability score
   */
  calculateExploitabilityScore(vuln) {
    let score = 0.3; // Base exploitability

    if (vuln.exploitCode) score += 0.4;
    if (vuln.metasploitModule) score += 0.5;
    if (vuln.weaponized) score += 0.6;
    if (vuln.remoteExploit) score += 0.3;
    if (vuln.noAuthRequired) score += 0.4;

    return Math.max(0, Math.min(1, score));
  }

  /**
   * Calculate business impact
   */
  calculateBusinessImpact(vuln) {
    let impact = 0.2; // Base impact

    // Confidentiality, Integrity, Availability impact
    if (vuln.confidentialityImpact === 'HIGH') impact += 0.3;
    if (vuln.integrityImpact === 'HIGH') impact += 0.3;
    if (vuln.availabilityImpact === 'HIGH') impact += 0.4;

    // Business context
    if (vuln.affectsCriticalSystems) impact += 0.3;
    if (vuln.affectsInternetFacing) impact += 0.2;

    return Math.max(0, Math.min(1, impact));
  }

  /**
   * Rule-based risk calculation as fallback/supplement
   */
  calculateRuleBasedRisk(vuln, context) {
    let risk = 0;

    // Base CVSS score
    if (vuln.cvssScore) {
      risk += vuln.cvssScore / 10;
    }

    // Exploitability bonus
    if (context.exploitabilityIndicators.includes('weaponized')) risk += 0.3;
    if (context.exploitabilityIndicators.includes('metasploit_module')) risk += 0.2;

    // Exposure bonus
    if (vuln.internetExposed) risk += 0.2;
    if (vuln.widespreadDeployment) risk += 0.1;

    return Math.max(0, Math.min(1, risk));
  }

  /**
   * Calculate confidence in assessment
   */
  calculateConfidence(mlRisk, ruleRisk, context) {
    let confidence = 0.5;

    // Data quality factors
    if (context.factors.length > 3) confidence += 0.2;
    if (mlRisk.confidence > 0.7) confidence += 0.2;

    // Consistency between ML and rule-based
    const consistency = 1 - Math.abs(mlRisk.score - ruleRisk);
    confidence += consistency * 0.3;

    return Math.max(0, Math.min(1, confidence));
  }

  /**
   * Generate AI-powered recommendations
   */
  async generateRecommendations(vuln, aiScores, context) {
    const recommendations = [];

    // Priority-based recommendations
    if (aiScores.overallRisk > 0.8) {
      recommendations.push({
        priority: 'CRITICAL',
        action: 'Immediate patching required',
        reasoning: 'AI assessment indicates extremely high risk',
        timeframe: 'Within 24 hours',
        automated: true
      });
    } else if (aiScores.overallRisk > 0.6) {
      recommendations.push({
        priority: 'HIGH',
        action: 'Schedule patching within SLA window',
        reasoning: 'AI assessment indicates high risk with active exploits',
        timeframe: 'Within 7 days',
        automated: false
      });
    }

    // Mitigation recommendations
    if (aiScores.exploitability > 0.7) {
      recommendations.push({
        priority: 'MEDIUM',
        action: 'Implement compensating controls',
        reasoning: 'High exploitability - consider network segmentation',
        timeframe: 'Within 30 days',
        automated: true
      });
    }

    // Business impact considerations
    if (aiScores.businessImpact > 0.8) {
      recommendations.push({
        priority: 'HIGH',
        action: 'Business impact assessment required',
        reasoning: 'Significant business impact predicted',
        timeframe: 'Immediate',
        automated: false
      });
    }

    return recommendations;
  }

  /**
   * Calculate risk timeline predictions
   */
  calculateRiskTimeline(vuln, aiScores) {
    const timeline = [];
    const now = new Date();

    // Immediate risk (next 24 hours)
    timeline.push({
      timeframe: '24h',
      riskIncrease: aiScores.exploitability > 0.8 ? 0.3 : 0.1,
      predictedRisk: Math.min(1, aiScores.overallRisk + (aiScores.exploitability > 0.8 ? 0.3 : 0.1)),
      factors: ['Active exploitation', 'Public exploits available']
    });

    // Short term (7 days)
    timeline.push({
      timeframe: '7d',
      riskIncrease: aiScores.exploitability > 0.6 ? 0.2 : 0.05,
      predictedRisk: Math.min(1, aiScores.overallRisk + (aiScores.exploitability > 0.6 ? 0.2 : 0.05)),
      factors: ['Increased exposure', 'Copycat attacks']
    });

    // Medium term (30 days)
    timeline.push({
      timeframe: '30d',
      riskIncrease: 0.1,
      predictedRisk: Math.min(1, aiScores.overallRisk + 0.1),
      factors: ['Patch availability', 'Competing threats']
    });

    return timeline;
  }

  /**
   * Assess asset value for business impact
   */
  assessAssetValue(affectedSystems) {
    let totalValue = 0;

    affectedSystems.forEach(system => {
      switch (system.criticality) {
        case 'CRITICAL': totalValue += 100; break;
        case 'HIGH': totalValue += 50; break;
        case 'MEDIUM': totalValue += 25; break;
        case 'LOW': totalValue += 10; break;
        default: totalValue += 5;
      }
    });

    return totalValue;
  }

  /**
   * Calculate exposure level
   */
  calculateExposureLevel(vuln) {
    let exposure = 0.2; // Base exposure

    if (vuln.internetExposed) exposure += 0.4;
    if (vuln.networkExposed) exposure += 0.3;
    if (vuln.hasPublicInterface) exposure += 0.3;

    return Math.min(1, exposure);
  }

  /**
   * Assess compliance impact
   */
  assessComplianceImpact(vuln) {
    const complianceFrameworks = ['PCI-DSS', 'HIPAA', 'NIST', 'ISO27001'];
    const impactedFrameworks = [];

    if (vuln.affectsCardholderData) impactedFrameworks.push('PCI-DSS');
    if (vuln.affectsHealthData) impactedFrameworks.push('HIPAA');
    if (vuln.severity === 'HIGH' || vuln.severity === 'CRITICAL') {
      impactedFrameworks.push('NIST', 'ISO27001');
    }

    return {
      impactedFrameworks,
      severity: impactedFrameworks.length > 0 ? 'HIGH' : 'LOW',
      requiresReporting: impactedFrameworks.length > 0
    };
  }

  /**
   * Get CWE description
   */
  getCWEDescription(cwe) {
    const cweDescriptions = {
      'CWE-79': 'Cross-site Scripting',
      'CWE-89': 'SQL Injection',
      'CWE-119': 'Buffer Overflow',
      'CWE-200': 'Information Disclosure',
      'CWE-287': 'Improper Authentication',
      'CWE-352': 'Cross-Site Request Forgery'
    };

    return cweDescriptions[cwe] || 'Unknown Vulnerability Type';
  }

  /**
   * Generate fallback assessment for error cases
   */
  generateFallbackAssessment(vuln) {
    return {
      vulnerabilityId: vuln.id || vuln.cveId,
      aiRiskScore: vuln.cvssScore ? vuln.cvssScore / 10 : 0.5,
      confidence: 0.3,
      exploitabilityScore: 0.5,
      businessImpact: 0.5,
      recommendations: [{
        priority: 'MEDIUM',
        action: 'Manual review required',
        reasoning: 'AI assessment failed - manual evaluation needed',
        timeframe: 'Within 7 days',
        automated: false
      }],
      riskTimeline: [],
      assessmentMetadata: {
        assessedAt: new Date().toISOString(),
        assessmentTime: 'N/A',
        modelVersion: 'fallback',
        factors: 0,
        error: true
      },
      context: { factors: [], relatedVulnerabilities: [], affectedSystems: [], exploitabilityIndicators: [], businessContext: {} }
    };
  }

  /**
   * Batch assessment for multiple vulnerabilities
   */
  async assessVulnerabilities(vulnerabilities) {
    const assessments = [];

    for (const vuln of vulnerabilities) {
      const assessment = await this.assessVulnerability(vuln);
      assessments.push(assessment);

      // Small delay to prevent overwhelming the system
      await new Promise(resolve => setTimeout(resolve, 10));
    }

    return {
      assessments,
      summary: this.generateBatchSummary(assessments),
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Generate batch assessment summary
   */
  generateBatchSummary(assessments) {
    const critical = assessments.filter(a => a.aiRiskScore > 0.8).length;
    const high = assessments.filter(a => a.aiRiskScore > 0.6 && a.aiRiskScore <= 0.8).length;
    const medium = assessments.filter(a => a.aiRiskScore > 0.4 && a.aiRiskScore <= 0.6).length;
    const low = assessments.filter(a => a.aiRiskScore <= 0.4).length;

    const avgRisk = assessments.reduce((sum, a) => sum + a.aiRiskScore, 0) / assessments.length;
    const avgConfidence = assessments.reduce((sum, a) => sum + a.confidence, 0) / assessments.length;

    return {
      totalAssessed: assessments.length,
      riskDistribution: { critical, high, medium, low },
      averageRisk: Math.round(avgRisk * 100) / 100,
      averageConfidence: Math.round(avgConfidence * 100) / 100,
      recommendations: this.generateBatchRecommendations(critical, high, medium)
    };
  }

  /**
   * Generate batch recommendations
   */
  generateBatchRecommendations(critical, high, medium) {
    const recommendations = [];

    if (critical > 0) {
      recommendations.push({
        priority: 'CRITICAL',
        action: `Address ${critical} critical vulnerabilities immediately`,
        impact: 'High business risk'
      });
    }

    if (high > 5) {
      recommendations.push({
        priority: 'HIGH',
        action: `Prioritize ${high} high-risk vulnerabilities`,
        impact: 'Medium business risk'
      });
    }

    if (medium > 10) {
      recommendations.push({
        priority: 'MEDIUM',
        action: `Review ${medium} medium-risk vulnerabilities`,
        impact: 'Low business risk'
      });
    }

    return recommendations;
  }
}

// Export singleton instance
const aiVulnerabilityScanner = new AIVulnerabilityScanner();
export default aiVulnerabilityScanner;
